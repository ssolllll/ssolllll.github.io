---
layout: page
title: "고성능 AI 서빙을 위한 로깅 아키텍처: 동기 vs 비동기"
description: "I/O 병목 제거를 위한 비동기 로깅 파이프라인 구축 및 성능 벤치마크"
img: assets/img/logging_architecture_thumb.jpg
importance: 2
category: MLOps
---

### 📌 프로젝트 개요
실시간 AI 에이전트 서비스에서 로그 기록(I/O)으로 인해 메인 프로세스가 멈추는 **I/O Wait** 문제를 해결하기 위한 프로젝트입니다. 동기 로깅의 한계를 극복하기 위해 **Queue 기반의 비동기 로깅 아키텍처**를 설계하고, 시스템 응답 속도를 극대화했습니다.

* **기술 스택:** Python QueueHandler, Threading, FastAPI, Redis(Log Buffer)
* **주요 기능:** Non-blocking 로깅 파이프라인, 멀티 스레드 기반 백그라운드 로그 처리

---

### 💡 단계별 기술적 고도화 (Technical Evolution)

#### 1. 동기 로깅의 병목 현상 진단
기본적인 동기 로깅 방식은 파일이나 콘솔에 로그가 완전히 기록될 때까지 메인 스레드가 대기해야 합니다. LLM 추론 결과가 나온 직후 로그를 남기는 과정에서 약 수십 $ms$의 지연이 추가로 발생하는 것을 확인하였으며, 이는 사용자 경험(UX) 저하로 직결되었습니다.

#### 2. 비동기 Queue 기반 아키텍처 설계
메인 로직과 I/O 작업을 분리하기 위해 Python의 `QueueHandler`와 `QueueListener`를 도입했습니다.
* **Worker-Producer 구조:** 메인 스레드(Producer)는 메모리 내 큐에 로그 데이터를 던지기만 하고 즉시 다음 작업을 수행합니다.
* **Consumer 구조:** 별도의 백그라운드 스레드(Consumer)가 큐를 모니터링하며 실제 디스크 쓰기 작업을 처리합니다.



#### 3. 지연 포맷팅과의 결합을 통한 시너지
비동기 큐에 '이미 연산이 끝난 긴 문자열'을 넣는 것보다 '원본 데이터'를 넣는 것이 메모리 효율적이라는 점에 착안했습니다.
* **Optimization:** 앞선 포스팅의 인사이트를 적용하여, 비동기 로깅 시 **지연 포맷팅**을 결합했습니다. 이를 통해 메인 스레드는 문자열 연산과 I/O 작업 모두로부터 자유로워지는 진정한 의미의 Non-blocking 로깅을 완성했습니다.

---

### 📈 기대 효과 및 성과
* **응답 속도 개선:** 로그 기록으로 인한 지연 시간을 거의 0ms에 가깝게 단축 (Main Thread 기준)
* **시스템 처리량 증가:** I/O 병목 제거를 통해 초당 처리 가능한 요청 수(RPS) 향상
* **안정성 확보:** 갑작스러운 트래픽 폭증 시에도 로그 버퍼링을 통해 서비스 안정성 유지